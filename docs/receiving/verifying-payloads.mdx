---
title: Verifying Payloads
---

import CodeTabs from '@theme/CodeTabs';
import TabItem from '@theme/TabItem';


Because of the way webhooks work, anyone can impersonate your service by sending a webhook to your endpoint. Think about it: it's just an HTTP POST from an unknown source. This is a potential security hole for many applications, or at the very least, a source of problems.

In order to prevent it, Svix signs every webhook and its metadata with a unique key for each endpoint. This signature can then be used to verify the webhook indeed comes from Svix, and only process it if it is.

Another potential security hole is what's called replay attacks. A [replay attack](https://en.wikipedia.org/wiki/Replay_attack) is when an attacker intercepts a valid payload (including the signature), and re-transmits it to your endpoint. This payload will pass signature validation, and will therefore be acted upon.

To mitigate this attack, Svix includes a timestamp for when the webhook attempt occurred. Our libraries automatically reject webhooks with a timestamp that are more than five minutes away (past or future) from the current time. This requires your server's clock to be synchronised and accurate, and it's recommended that you use [NTP](https://en.wikipedia.org/wiki/Network_Time_Protocol) to achieve this.


## Verifying signatures using our official libraries

First install the libraries if you haven't already:

<CodeTabs>
<TabItem value="js">

```js
npm install svix
// Or
yarn add svix
```

</TabItem>
<TabItem value="py">

```sh
pip install svix
```

</TabItem>
<TabItem value="go">

```shell
go get github.com/svixhq/svix-libs/go
```

</TabItem>
<TabItem value="curl">

```shell
# Install cURL. E.g. on arch linux:
pacman -S curl
```

</TabItem>
</CodeTabs>

Then verify webhooks using the following:

<CodeTabs>
<TabItem value="js">

```js
import { Webhook } from "svix";

const secret = "MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw";

// These were all sent from the server
const headers = {
  "svix-id": "msg_p5jXN8AQM9LWM0D4loKWxJek",
  "svix-timestamp": "1614265330",
  "svix-signature": "v1,g0hM9SsE+OTPJTGt/tmIKtSyZlE3uFJELVlNIOLJ1OE=",
};
const payload = '{"test": 2432232314}';

const wh = new Webhook(secret);
// Throws on error, returns the verified content on success
const payload = wh.verify(payload, headers);
```

</TabItem>
<TabItem value="py">

```python
from svix import Webhook

secret = "MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw"

# These were all sent from the server
headers = {
  "svix-id": "msg_p5jXN8AQM9LWM0D4loKWxJek",
  "svix-timestamp": "1614265330",
  "svix-signature": "v1,g0hM9SsE+OTPJTGt/tmIKtSyZlE3uFJELVlNIOLJ1OE=",
}
payload = '{"test": 2432232314}'

wh = Webhook(secret);
# Throws on error, returns the verified content on success
payload = wh.verify(payload, headers);
```

</TabItem>
<TabItem value="go">

```go
import (
	svix "github.com/svixhq/svix-libs/go"
)

secret := "MfKQ9r8GKYqrTwjUPD8ILPZIo2LaLaSw"

// These were all sent from the server
headers := http.Header{}
headers.Set("svix-id", "msg_p5jXN8AQM9LWM0D4loKWxJek")
headers.Set("svix-timestamp", "1614265330")
headers.Set("svix-signature", "v1,g0hM9SsE+OTPJTGt/tmIKtSyZlE3uFJELVlNIOLJ1OE=")

payload := []byte(`{"test": 2432232314}`)

wh, err := svix.NewWebhook(secret)
err := wh.Verify(payload, headers)
// returns nil on success, error otherwise
```

</TabItem>
<TabItem value="curl">

No easy way to verify the signature just with cURL.

</TabItem>
</CodeTabs>

## Verifying signatures manually

Each webhook call includes three headers with additional information that are used for verification:

* `Svix-Id`: the unique message identifier for the webhook message. This identifier is unique across all messages, but will be the same when the same webhook is being resent (e.g. due to a previous failure).
* `Svix-Timestamp`: timestamp in [seconds since epoch](https://en.wikipedia.org/wiki/Unix_time).
* `Svix-Signature`: the [Base64](https://en.wikipedia.org/wiki/Base64) encoded signature.

### Constructing the signed content

The signature is composed by concatenating the following the id, timestamp and payload, separated by the full-stop character `.`. Which in code will look something like:

```javascript
signed_content = "${svix_id}.${svix_timestamp}.${body}"
```

Where `body` is the raw body of the request. The signature is sensitive to any changes, so even a small change in the body will cause the signature to be completely different. This means that you should *not* change the body in any way before verifying.

### Determining the expected signature

Svix uses an [HMAC](https://en.wikipedia.org/wiki/Hash-based_message_authentication_code) with [SHA-256](https://en.wikipedia.org/wiki/SHA-2) to sign its webhooks.

So to calculate the expected signature, you should HMAC the `signed_content` from above using your secret webhook signature key. This generated signature should match the one sent in the `Svix-Signature` header.

Please note that to compare the signatures it's recommended to use a constant-time string comparison method in order to prevent timing attacks.

### Verify timestamp

As mentioned above, Svix also sends the timestamp of the attempt in the `Svix-Timestamp` header. You should compare this timestamp against your system timestamp and make sure it's within your tolerance in order to prevent timestamp attacks.


## Building your own libraries

Depending on your product you may want to offer additional processing before passing the verified payload for your customers. For example, you may want to create API objects from the payload that your users can use to interact with your API.

In this scenario you would want to create your own `Webhook` class equivalent that uses the `Svix` class internally. This way you can get all of the verification that Svix offer, while still being able to post-process the payload before passing it to your users.
